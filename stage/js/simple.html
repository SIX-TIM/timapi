<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">

  <link href="../assets/css/vendors.css" rel="stylesheet">
  <link href="../assets/css/helppage.css" rel="stylesheet">
  <link href="res/css/lang_specific.css" rel="stylesheet">

  <title>TIM API documentation</title>
  <script src="../assets/js/vendors.js"></script>
  <script src="../assets/js/helppage.js"></script>
  <script src="../assets/js/guide.js"></script>
  <script src="../assets/js/tim_inject.js"></script>
  <script src="../assets/js/sdk_version.js"></script>
  <script src="../assets/js/config.js"></script>
  <script src="api_version.js"></script>
</head>
<body data-spy="scroll" data-target="#navScrollspy">
  <div class="container-fluid" id="content">
    <div>
      <nav id="navScrollspy">
        <div id="stageBanner">STAGING VERSION!</div>
        <div id="archiveBanner">ARCHIVED VERSION!<br><a href="../../../doc/index.html" id="currentLink">-&gt; link to current version</a></div>
        <div class="affix" data-spy="affix" id="navbar">
          <div id="projectname">TIM SDK</div>
          <div id="projectbrief">TIM API</div>
          <div id="vSep">&#160;</div>
          <div id="langSel">
            <ul class="langList">
              <li>
                <a class="lang_java" href="../java/simple.html">Java</a>
              </li>
              <li>
                <span style="color: gray">.NET</span>
              </li>
              <li>
                <a class="lang_swift" href="../swift/guide.html">Swift</a>
              </li>
              <li>
                <a class="lang_js" href="../js/simple.html">JavaScript</a>
              </li>
              <li>
                <a class="lang_c" href="../c/guide.html">C</a>
              </li>
            </ul>
          </div>
          <div id="guideDiv">
            <div id="guideTitle">Guide Selection<div class="close_icon" id="closeGuideSel"></div></div>
            <div id="guideSel"></div>
          </div>
          <div id="docTitle">Simple Implementation Guide</div>
          <ul class="nav">
          <li><a href="#simpleIntro">Introduction</a></li><li><a href="#usageLibrary">Library usage</a></li><li><a href="#usageSettings">Minimal Settings</a></li><li><a href="#simpleTransaction">Simple Transaction</a></li><li><a href="#simpleResponse">Simple Response Handling</a></li><li><a href="#MigrationJStoWASM">Migration from old TIM API JS to TIM API JS with WebAssembly</a><ul class="nav"><li><a href="#MigrationJSInit">Ready Initialization</a></li><li><a href="#MigrationJSNames">Class Variable Names</a></li><li><a href="#MigrationJSListenerDeclaration">Listener Declaration</a></li><li><a href="#MigrationJSLogging">Logging</a></li></ul></li></ul>
          <div class="seperator">&#160;</div>
          <div class="linkDiv">
            <a href="appendix.html">Appendix</a>
          </div>
          <div class="linkDiv">
            <a href="doc/timapi.Terminal.html">API Documentation</a>
          </div>
          <div class="linkDiv">
            <a href="../../version/version-history.html">Version History</a>
          </div>
        </div>
      </nav>

      <span class="print-page-break"></span>

      <main>
      <section id="simpleIntro"><h1><a name="simpleIntro"></a>Introduction</h1><div class="row"><div class="col-md-6"><p>The following sections give a simple overview how to make a simple TIM API integration
      without any special configurations. Therefore default values are used as often as possible to keep it simple.
      If special features are required, visit the section <a href="guide.html">Integration in Detail</a>
      for a more sophisticated overview.
    </p>
  </div></div></section>
  <section id="usageLibrary"><h1><a name="usageLibrary"></a>Library usage</h1><div class="row"><div class="col-md-6"><p>As the TIM SDK offers the TIM API in multiple languages you can chose the one that is suitable for your platform.
      To use the TIM API <span lang="JS">Javascript there are two deliverables required, the "timapi.wasm" WebAssembly module and the "timapi.js". They can be used in two ways:
          <p>
            <ul>
              <li>Either you use the TIM API Javascript in a web context in conjunction with a webbrowser. If so you require a webserver as the TIM API Javascript
                has a core written in C, compiled into WebAssembly format and a Javascript interface layer. Due to security restrictions of the webbrowsers the .wasm WebAssembly module
                must be placed on a webserver next to the webpage and the timapi.js Javascript interface layer, as it is not allowed to load local modules via JavaScript in a webbrowser.</li>
                <li>Or you can use it in conjunction with e.g. NodeJS for local usage. If you use it outside of a webbrowser, no webserver is required as there are no such security restrictions
                  in conjunction with NodeJS.</li>
                </ul>
              </p>
            </span>
            </p>
          </div></div></section>
          <section id="usageSettings"><h1><a name="usageSettings"></a>Minimal Settings</h1><div class="row"><div class="col-md-6"><p>To start right away only a minimal set of settings has to be given:
              <ul> <li>Terminal IP: The IP of the terminal that shall be used afterwards. Used if direct connection is used: ConnectionMode = OnFixIp</li>
                <li>ConnectionMode: Only if "OnFixIp" with set Terminal IP shall be used. </li>
                <li>AutoCommit: Defines if terminal performs a Commit automatically or if it must be done from the ECR. (Default: AutoCommit = true)</li>
              </ul>
            </p>
            <p>This minimal configuration can be done directly in the code after creating a<code><a>TerminalSettings</a></code> instance.</p>
            </div></div><div class="row"><div class="col-md-6">
                <p>This block shows the setup with the fixed ip connection mode: <pre><code class="language-{.js}">// Create new TerminalSettings instance
var settings = new timapi.TerminalSettings()	

// ----------------------------CONNECTION----------------------------

//IP address of the terminal.
settings.connectionIPString = "192.168.2.12";

//Port to be used for connection.
// Port list:
// 80 - Standard port for ws:// connection
// 8080 - If ports below 1024 are privileged and cannot be used.
settings.connectionIPPort = 80; 

// ----------------------------COMMIT----------------------------

// If the ECR shall be responsible to perform a commit the following parameter has to be set.
// Otherwise the terminal performs a commit automatically.
settings.autoCommit = false;

// ----------------------------CREATE TERMINAL INSTANCE----------------------------

// Create a terminal instance using the adjusted terminalSettings object
var terminal = new timapi.Terminal(settings);

</code></pre></p>
                    <p>After the Terminal instance has been created it can be used to perform transactions.</p>
                  </div><div class="col-md-6">
                    </div></div>
              <div class="row"><div class="col-md-6"></div></div></section>
              <section id="simpleTransaction"><h1><a name="simpleTransaction"></a>Simple Transaction</h1><div class="row"><div class="col-md-6">
                    <p>
                      The flow on the right shows a simple transaction flow and which steps are done by which participant.
                      Note that for a simple use the integrator only needs to follow 4 simple steps, steps 1 to 4. Steps 1-4 can be performed multiple times (loop) if wished.
                      The rest, steps A to G, will be done either by the TIM API itself or by the terminal if required.
                    </p>
                    <p>
                      The steps the integrator has to perform are the following:
                      <ul>
                        <li><b>1. Start transaction: </b>The integrator has to call the <code><a>transactionAsync</a></code> function including the required parameters which are shown in the code example below.</li>
                      <li><b>2. Process transaction completed: </b>After processing the transaction the TIM API will return a <code><a>transactionResponse</a></code>in the corresponding <code><a>transactionCompleted</a></code> callback method.</li>
                    <li><b>3. Send commit (if AutoCommit deactivated): </b>After receiving the feedback in the transactionCompleted callback the integrator has to call the <code><a>commitAsync</a></code> function to complete the transaction process.
                    This step must only be done if AutoCommit has been set to "false" in the terminal settings.</li>
                  <li><b>4. Process commit completed (if AutoCommit deactivated): </b>Also the commit function is finished from the TIM API by calling the <code><a>commitCompleted</a></code> callback function.
                  After getting the commit completed callback call from the TIM API, another requests, e.g. another transaction, can be called.</li>
              </ul>
            </p>
            <p>
              The following steps are performed by the TIM API or the terminal if they are required:
              <ul>
                <li><b>A.</b> : The TIM API automatically connects to the terminal and makes the required Login to set the
                specified connection parameters. If successful a shift will be opened on the terminal by calling Activate from the TIM API automatically.
                These steps are only performed if they are required which means the terminal was not yet in the corresponding state and not yet ready to accept a transaction:
                <ul>
                  <li>If the terminal is already connected, no connect is required.</li>
                  <li>If the terminal is already in LoggedIn state, no login is required.</li>
                  <li>If the terminal is already in Activated state (open shift), no activate is required.</li>
                </ul>
              </li>
              <li><b>B.</b> : After the TIM API performed all steps needed to bring the terminal into the required state, the transaction request
              is sent to the terminal.
            </li>
            <li><b>C.</b> : The terminal performs the transaction (e.g. cardholder verification, transaction authorization etc.)
          </li>
          <li><b>D.</b> : The terminal returns the outcome of the transaction to the TIM API.
        </li>
        <li><b>E.</b> : The TIM API sends the commit request to the terminal (will be done automatically, if AutoCommit is activated).
      </li>
      <li><b>F.</b> : The terminal processes the commit request.
    </li>
    <li><b>G.</b> : The terminal sends the commit response to the TIM API.
  </li>
</ul>
</p>
<p>In code this may look as follows:</p>
<pre><code class="language-{.js}">function initTimApi(){
 exampleEcr = this;

 // Define all required settings
 var settings = new timapi.TerminalSettings()

 // Minimal settings
 settings.connectionIPString = "10.48.198.250";
 settings.connectionIPPort = 80;

 settings.autoCommit = false;
 
 // The integrator id is provided by SIX Payment Services / Worldline
 // to indentify the integrator for support purposes.
 settings.integratorId = "0e6b1705-ab96-455b-9ba3-a77dd919d7a5";

 // Create terminal object with 
 exampleEcr.terminal = new timapi.Terminal(settings);
 exampleEcr.terminal.posId = "ECR-01";
 exampleEcr.terminal.userId = 1;

 class mylistener = new timapi.DefaultTerminalListener(){
   terminalStatusChanged(event, data) {
    super.terminalStatusChanged(event, data);
    // Do Stuff
   }

   transactionCompleted(event, data){
    super.transactionCompleted(event, data);
    //Do Stuff
   }
 }

 exampleEcr.terminal.addListener(myListener);
}

//A standard purchase transaction can be implemented as follows
function purchase(amount, currency, exponent) {
 try {
  // Prepare an timapi amount object for the current transaction 
  var myAmount  = new timapi.Amount(amount, currency, exponent);

  // Perform the purchase transaction
  terminal.transactionAsync(timapi.constants.TransactionType.purchase, myAmount);
 } catch( err ) {
  console.Log("Error:\n" + err);
 }
}

//To finalize a transaction and if AutoCommit = false,
//the commit function must be used. An implementation could
//look as follows.
function commit() {
 try {

  // Perform the commit
  terminal.commitAsync();
 } catch( err ) {
  console.Log("Error:\n" + err);
 }
}
</code></pre>
</div><div class="col-md-6">
  <figure><img src="../assets/img/QuickTrxFlow_v6.png"><figcaption>Simple Transaction Flow</figcaption></figure>
</div></div>
<div class="row"><div class="col-md-6"></div></div></section>
<section id="simpleResponse"><h1><a name="simpleResponse"></a>Simple Response Handling</h1><div class="row"><div class="col-md-6">
      <p>The following section explains how to easily retrieve response data from the <code><a>TransactionResponse</a></code> which is available after a transaction as described above.</p>
        <p>The first step is to implement your own terminal listener class wherein you overwrite the functions you want to use.
          If you are mainly interested in the transaction response you can use the following code:</p>
          <pre><code class="language-{.js}">/** Asynchronous listener handling terminal events. */

/* Define your own TerminalListener by overwrite all required 
 * methods from the DefaultTerminalListener class
 * which you want to use.
*/
class MyTerminalListener extends timapi.DefaultTerminalListener {

// Overwrite all methods of the DefaultTerminalListener hererin

}

/* Then create an instance of your "MyTerminalListener" and add it to
 * your terminal instance.
*/
var myListener = new MyTerminalListener();

terminal.addListener(myListener);


</code></pre>
          <h2>Check transaction outcome</h2>
          <p>To check if a transaction has been performed successfully you have to check the <code><a>ResultCode</a></code>which is part of the object in the<code><a>transactionCompleted</a></code> callback.</p>
          <p>Further error information can be retrieved as described in the API documentation in the section.</p>
            <hr>
            <h2>Print data</h2>
            <p>
              The <code><a>TransactionResponse</a></code> has a member <code><a>PrintData</a></code>
              (accessed via <code><a>getPrintData</a></code>) which contains merchant and cardholder receipts.
            </p>
            <p>The <code><a>PrintData</a></code> returned in the
            <code><a>TransactionResponse</a></code> contains a merchant and
            a cardholder receipt which can be retrieved in the <code><a>transactionCompleted</a></code>
            callback using the <code><a>getPrintData</a></code> function. The <code><a>PrintData</a></code> object
            then contains a list of <code><a>Receipt</a></code> objects which can be retrieved individually.</p>
            <hr>
            <h2>Card data</h2>
            <p>To retrieve card specific information the <code><a>CardData</a></code> object is also available in
            the <code><a>TransactionResponse</a></code>. This object contains several card information that
            was available to the terminal during the transaction process.</p>
            <hr>
            <h2>Further transaction information</h2>
            <p>Further information regarding the transaction can be found in the <code><a>TransactionInformation</a></code> object.</p>
          </div><div class="col-md-6">
            <p>The following code shows how the information mentioned above can be retrieved in the
              <code><a>transactionCompleted</a></code> event:</p>
              <pre><code class="language-{.js}">/* These completed functions have to be implemented in your "MyTerminalListener"
 * class to overwrite the default implementation.
 * You decide which functions you want to use.
*/
class MyTerminalListener extends timapi.DefaultTerminalListener {

transactionCompleted(event, data){
  super.transactionCompleted(event, data);

/*--- Check transaction outcome ---------------------------------------*/

  // Check if transaction has been successful
  if (event.exception == undefined)
  {
    console.log("Transaction was performed successfully!");

/*--- Print data ------------------------------------------------------*/

    // Further information can be retrieved as the transaction has be successful

    // Get print data which contains a list of receipts
    if (data != undefined &amp;&amp; data.printData != undefined){
      var myPrintData = data.printData;

      // Go through all available receipts and print them accordingly
      if(myPrintData.receipts != undefined){
      var myReceipts = myPrintData.receipts;

      // If you want to differ bewteen merchant and cardholder receipt
      for (var i = 0; i &lt; myReceipts.length; i++) {
      // Get merchant receipt
      if(myReceipts[i].recipient == timapi.constants.Recipient.merchant){
	console.log("Merchant receipt: ", myReceipts[i].value);
      }
      // Get cardholder receipt
      if(myReceipts[i].recipient == timapi.constants.Recipient.cardholder){
	console.log("Cardholder receipt: ", myReceipts[i].value);
      }
      }
    }

/*--- Card data -------------------------------------------------------*/

    // Get CardData which contains all available card information
    if (data.cardData != undefined){
      var myCardData = data.cardData;

      // Further card information can be retrieved out of the CardData object
      // e.g. AID or BrandName etc...
      var aid = myCardData.aid;
      var brandName = myCardData.brandName;
    }
/*--- Further transaction information ---------------------------------*/

    // Further transaction information is available in the TransactionInformation object
    if (data.transactionInformation != undefined){
      var myTrxInfo = data.transactionInformation;

      // This object contains e.g. acquirer id or transaction reference and more information..
      var acqId = myTrxInfo.acqId;
      var acqTransRef = myTrxInfo.acqTransRef; // If available
      var trmTransRef = myTrxInfo.trmTransRef;

    }

/*---------------------------------------------------------------------*/
  }

  // If the transaction has not been successful the result code can
  // be retrieved as follows to determine what went wrong
  else
  {
    console.log("Transaction was NOT performed successfully:", 
    event.exception.resultCode);
  }
 }
}

</code></pre>
            </div></div>
        <div class="row"><div class="col-md-6"></div></div></section>
        <section id="MigrationJStoWASM"><h1><a name="MigrationJStoWASM"></a>Migration from old TIM API JS to TIM API JS with WebAssembly</h1><div class="row"><div class="col-md-6"><p>The following sections will provide information which changes have to be made to switch from the old TIM API JS solution
        to the new TIM API JS with WebAssembly. Each section contains an example of the old TIM API JS and one of the new TIM API JS with
        WebAssembly to directly show the differences.</p>
          </div></div><section id="MigrationJSInit"><h2><a name="MigrationJSInit"></a>Ready Initialization</h2><div class="row"><div class="col-md-6"><p>Below is an example how the TIM API must be initialized to be available.</p>
          </div></div><div class="row"><div class="col-md-6">
<p>With the old TIM API JS it was essential to check if the TIM API was available before using it. This
could be done with the following check:</p>
  <pre><code>if(timapi == undefined){
     // TIM API not ready
   }else{
     // Start using TIM API
   }</code></pre>
      </div><div class="col-md-6">
          <p>In the new TIM API JS with WebAssembly a callback function is called as soon as the TIM API
          is ready to be used by the application:</p>
<pre><code>onTimApiReady = function() {
   // Start using TIM API
}</code></pre>
</div></div>
          <div class="row"><div class="col-md-6"></div></div></section>
          <div class="row"><div class="col-md-6"></div></div><section id="MigrationJSNames"><h2><a name="MigrationJSNames"></a>Class Variable Names</h2><div class="row"><div class="col-md-6"><p>The naming of class variable names changed slightly:</p>
          </div></div><div class="row"><div class="col-md-6">
<p>Old TIM API JS used variables names with a '$'-sign like this:</p>
<pre><code>settings.$connectionIPString = "..."</code></pre>
</div><div class="col-md-6">
          <p>New TIM API JS with WebAssembly uses variables names like this (if " or ' is not important. JS supports both):</p>
<pre><code>settings.connectionIPString = '...'</code></pre>
          
</div></div>
          <div class="row"><div class="col-md-6"></div></div></section>
          <div class="row"><div class="col-md-6"></div></div><section id="MigrationJSListenerDeclaration"><h2><a name="MigrationJSListenerDeclaration"></a>Listener Declaration</h2><div class="row"><div class="col-md-6">
          <p>The old TIM API JS used a non-OOP like way to create listeners. A DefaultTerminalListener was created and then the
respective methods were "replaced":</p>
<pre><code>var listener = new timapi.DefaultTerminalListener();
listener.terminalStatusChanged = function (_terminal) {
  timapi.DefaultTerminalListener.prototype.terminalStatusChanged(_terminal);
  // Do stuff
}

listener.connectCompleted = function (_event) {
  timapi.DefaultTerminalListener.prototype.connectCompleted(_event);
  // Do stuff
}

listener.transactionCompleted = function(_event, _data) {
  timapi.DefaultTerminalListener.prototype.transactionCompleted(_event, _data);
  // Do stuff
}</code></pre>
          </div><div class="col-md-6">
          <p>
The new TIM API JS with WebAssembly uses proper subclassing like this:</p>

<pre><code>class UpdateUIEnabledListener extends timapi.DefaultTerminalListener {
   terminalStatusChanged(terminal) {
    super.terminalStatusChanged(terminal);
     ...
   }
   requestCompleted(event, data) {
     super.requestCompleted(event, data)
     ...
   }
 }</code></pre>
          </div></div>
          <div class="row"><div class="col-md-6"></div></div></section>
          <div class="row"><div class="col-md-6"></div></div><section id="MigrationJSLogging"><h2><a name="MigrationJSLogging"></a>Logging</h2><div class="row"><div class="col-md-6">
<p>In the old TIM API JS there was only the possibility to set the logging level but there was no chance to
control the logging messages on user application level:</p>
<pre><code>timapi.logging.Log.logLevel = timapi.logging.Level.FINE</code></pre>
</div><div class="col-md-6">
          <p>
This is not existing anymore in WebAssembly. Instead the logger goes to the web console by default
but can be intercepted by the user application like this:</p>
<pre><code>onTimApiLog = function(message) {
   ... // message is of type String
 }</code></pre>

<p>Which allows to simply output a final predefined log message.</p>

<p>To further filter the logMessages the "onTimApiPublishLogRecord" function can be used.</p>
</div></div>
          <div class="row"><div class="col-md-6"></div></div></section>
        <div class="row"><div class="col-md-6"></div></div></section>

      </main>
    </div>
  </div>
</body>

</html>